# 第一章 计算机系统概述

[TOC]

## 1.1 操作系统的基本概念

### 1.1.1 操作系统的概念

​		操作系统是指控制和管理整个计算机系统的硬件与软件资源，合理地组织、调度计算机的工作与资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合。操作系统是计算机系统中最基本的系统软件。

### 1.1.2 操作系统的特征

1. 并发
   - 指多个事件在同一时间间隔内发生，宏观同时发生，微观交替发生。
   - 与并行不同，并行指的是多个事件在同一时刻同时发生。
   - 单核 CPU 同一时刻只能执行一个程序，各个程序只能并发执行。
   - 多核 CPU 同一时刻可以同时执行多个程序，多个程序可以并发执行。
   - 引入进程的目的是使程序能并发执行。
   - 并发性通过分时得以实现。
2. 共享
   - 共享指的是资源共享，系统中的资源可供内存中多个并发执行的进程共同使用。
   - 互斥共享方式包括 ① 一个时间段内只允许一个进程访问该资源；② 临界资源指的是一个时间段内只允许一个进程访问的资源；③ 大多数物理设备，某些软件的栈、变量和表格都是临界资源。
   - 同时共享方式指的是一个时间段内允许多个进程“同时”对它们进行访问，如磁盘，“同时”的意思是宏观同时，微观可能交替。
3. 虚拟
   - 虚拟指的是把一个物理上的实体变为若干个逻辑上的对应物。物理实体是实际存在的，逻辑上的对应物是用户感受到的。
   - 一个程序需要放入内存并给它分配 CPU 才能执行。
   - 虚拟技术分为时分复用技术和空分复用技术。
   - 没有并发性就谈不上虚拟性。
4. 异步
   - 程序以不可预知的速度向前推进。
   - 只有系统拥有并发性，才有可能导致异步性。
   - 只要运行环境相同，操作系统就须保证多次运行进程后都能获得相同的结果。

**Q：线程和进程分别是什么？**

> ​		进程可以被看作是一个正在运行的应用程序的实例，它拥有独立的内存空间和系统资源。例如，当你打开一个浏览器时，你就启动了一个浏览器进程，这个进程运行着浏览器的各种功能，并且与其他应用或系统进程相互独立。
>
> ​		线程则是进程内的一个执行路径，是操作系统进行运算调度的最小单位。同一个进程中的所有线程共享该进程的内存空间和其他资源。比如，在浏览器进程中，可能有多个线程同时运行，一个负责加载网页内容，另一个负责处理用户交互，它们协同工作以提高效率。

**Q：举例说明互斥共享方式。**

> 假设在一个办公室中，多个人通过各自的电脑共享一台打印机。
>
> ① 一个时间段内只允许一个进程访问该资源：
>
> ​		当某个用户的文档正在打印时，其他用户必须等待，直到当前打印任务完成。打印机这个资源在同一时间只能被一个进程（打印任务）使用。
>
> ② 临界资源指的是一个时间段内只允许一个进程访问的资源：
>
> ​		打印机属于临界资源，需要通过互斥机制来管理访问。
>
> ③ 大多数物理设备、某些软件资源（如栈、变量和表格）都是临界资源：
>
> ​		假设有两个线程同时对一个全局变量 count 执行 count++ 操作，而没有互斥保护，最终结果可能不是预期值。

**Q：举例说明虚拟性质。**

> ① 虚拟指的是把一个物理上的实体变为若干个逻辑上的对应物：
>
> ​		例如多个进程可以同时写入打印队列，操作系统负责将它们的请求排队，按顺序输出到真正的打印机。对用户来说，自己仿佛独占打印机，实际上是在共享。
>
> ② 一个程序需要放入内存并给它分配 CPU 才能执行：
>
> ​		假设有一个 Word 程序（磁盘文件），当双击 Word 图标时，操作系统会把 Word 程序的指令和数据加载到内存，创建一个进程。然后通过调度算法，分配 CPU 时间， Word 程序才能真正开始运行。

Q：举例说明异步性质。

> ① 程序以不可预知的速度向前推进：
>
> ​		程序A和程序B的推进速度是不可预知的，下一步谁先执行、谁后执行完全取决于操作系统的调度。
>
> ② 只要运行环境相同，操作系统就须保证多次运行进程后都能获得相同的结果：
>
> ​		同一个程序在相同输入、相同硬件、相同系统版本、相同运行环境下，重复运行时应该得到相同的执行结果，不能出现随机错误，否则会导致程序行为混乱。

### 1.1.3 操作系统的目标和功能

1. 作为计算机系统资源的管理
   - 功能包括：① 处理机管理：处理机的分配和运行都以进程为基本单位；② 存储器管理；③ 文件管理；④ 设备管理。
   - 目标是安全和高效。
2. 作为用户与计算机硬件系统之间的接口
   - 命令接口
     - 联机命令接口：交互式命令接口（用户说一句，系统做一句）
     - 脱机命令接口：批处理命令接口（用户说一堆，系统做一堆）
   - 程序接口：① 由一组系统调用组成；② 普通用户不能直接使用程序接口，只能通过程序代码间接使用；③ 请求操作系统为其提供服务。
3. 实现了对计算机资源的扩充
   - 扩充机器

**Q：举例说明作为计算机系统资源的管理。**

> ① 处理机管理（CPU管理）：
>
> ​		假设有三个进程：进程A：下载文件、进程B：播放音乐、进程C：打开浏览器。操作系统会：按时间片轮流给每个进程分配 CPU。当进程 A 占用完时间片后，操作系统会切换 CPU 给进程 B。每个进程运行一点，再切换，快速轮转。处理机管理的目标是：让 CPU 高效使用，进程公平竞争。
>
> ② 存储器管理：
>
> ​		假设进程 A 申请内存用于加载网页、进程 B 申请内存用于视频缓冲。操作系统会为每个进程分配独立的虚拟内存空间。存储器管理的目标是：合理利用内存，保证进程间安全隔离。
>
> ③ 文件管理：
>
> ​		假设用户创建一个 Word 文档，保存在 D 盘，另一个进程正在读取图片文件。操作系统会建立文件表，并控制不同进程对文件的访问权限，防止冲突。
>
> ④ 设备管理：
>
> ​		假设进程 A 请求打印一个文档，进程 B 请求读取 U 盘文件。操作系统会通过设备驱动程序，控制打印机和 U 盘的具体操作。为进程 A 排队分配打印任务，防止多个进程同时操作设备导致冲突。提供统一的设备接口（如读写操作），让程序不关心设备型号。
>

**Q：什么是程序接口？**

> ​		程序接口是操作系统为应用程序提供的“服务请求通道”，由系统调用组成。例如，用户用 C 语言写 fd = open("file.txt", O_RDONLY); 这段代码，这个 open() 函数实际上会触发一个系统调用，请求操作系统打开文件。这就是程序接口，通过系统调用间接请求操作系统服务。

**Q：什么是扩充机器？**

> ​		操作系统通过虚拟化，把计算机变成了一台“扩充机器”，用户看到的资源远比物理实际提供的要多。例如，多个进程同时访问打印机、硬盘，感觉像各自独占设备。

## 1.2 操作系统的发展阶段和分类

1. 手工操作阶段（第一代计算机）

   ​		该阶段没有操作系统，比如程序员用打孔卡输入程序，把打孔卡一张一张插入读卡机，人工控制计算机运行、结束，结果打印在纸上。缺点是用户独占全机，人机速度矛盾。

2. 批处理阶段（IBM 批处理系统）

   ​		操作系统出现，开始自动化管理作业。用户将多个作业交给操作系统统一批量处理，人不需要实时干预。

   - 单道批处理系统：

     ​		假设有三个作业：作业 A：编译一个程序（运行时间 5 分钟）、作业 B：打印一份报表（运行时间 3 分钟）、作业 C：进行数据备份（运行时间 7 分钟）。单道批处理系统会：先运行作业 A，作业 A 结束后，才能运行作业 B；作业 B 结束后，才能运行作业 C。单道批处理系统的特点是作业串行运行，系统资源利用率低。CPU 等待 I/O 的时间浪费严重。

   - 多道批处理系统：

     ​		还是上面举例的三个作业，多道批处理系统会：把作业 A、B、C 一起加载进内存。当作业 A 进行 I/O（比如读取磁盘）时，CPU 立刻切换去运行作业 B。当作业 B 也等待 I/O 时，CPU 再切换去运行作业 C。这样 CPU 几乎不会闲着，始终处于工作状态。

3. 分时操作系统（Linux）

   ​		支持多个用户同时在线交互，通过时间片轮转，多个程序“看起来”同时运行。多个用户通过终端同时登录：用户A运行程序、用户B编辑文件、用户C上网浏览。系统快速轮换 CPU 时间给每个用户，达到“实时响应”的效果。

   ​		特点是同时性、交互性、独立性和及时性。缺点是不能优先处理紧急任务，优点是提供了人机交互功能。

4. 实时操作系统（飞机控制，订票系统）

   ​		为了能在某个时间限制内完成某些紧急任务而不需要时间片排队，诞生了实时操作系统，其具有及时性和可靠性的特点。

   ​		这里的时间限制可以分为两种情况：若某个动作必须绝对地在规定的时刻（或规定的时间范围）发生，则称为硬实时系统，如飞行器的飞行自动控制系统，这类系统必须提供绝对保证，让某个特定的动作在规定的时间内完成。

   ​		若能够接受偶尔违反时间规定且不会引起任何永久性的损害，则称为软实时系统，如飞机订票系统、银行管理系统。

## 1.3 操作系统的运行环境

### 1.3.1 操作系统的运行机制

1. 内核态和用户态

   ​		CPU 内部有一个小开关（程序状态字寄存器 PSW），当小开关为 1 时，CPU 处于核心态，此时 CPU 可以执行特权指令；当小开关为 0 时，CPU 处于用户态，此时 CPU 只能执行非特权指令。用户自编程序运行在用户态，操作系统内核程序运行在核心态。

2. 特权指令和非特权指令

   ​		特权指令由内核程序执行，不允许用户直接使用的指令；非特权指令指允许用户直接使用的指令，不能直接访问系统中的软硬件资源，仅限于访问用户的地址空间，防止用户程序对系统造成破坏。

3. 内核

   - 时钟管理：通过时钟中断的管理可以实现进程的切换，利用时钟中断实现计时功能。
   - 中断机制：只有一小部分功能属于内核，中断是一种强制打断当前程序执行的机制，用于响应硬件设备或程序请求。
   - 原语：是操作系统中不可被打断的小段关键代码，用于实现对资源的保护。① 不可被中断；② 处于操作系统最底层，是最接近硬件的部分；③ 运行时间短，调用频繁。
   - 系统控制的数据结构及处理：① 进程管理；② 存储器管理；③ 设备管理。

**Q：什么是时钟管理？**

> ​		在分时操作系统中，CPU 给每个进程分配时间片（比如 50 毫秒）。当时间片用完，时钟中断会触发，操作系统内核立即切换到下一个进程。如果没有时钟管理，系统无法公平切换进程。

**Q：什么是中断机制？**

> ​		当按下键盘，键盘会向 CPU 发送一个中断请求。CPU 暂停当前进程，转去处理中断（读取键盘输入）。处理完成后，CPU 继续执行原来的进程。就比如，你正在写作业，突然有人敲门，你必须停下来去开门，处理完后继续做作业。

**Q：什么是原语？**

> ​		比如操作系统中的关中断、开中断指令、进程切换时保存 CPU 状态的过程、信号量的 加锁、解锁，这些动作必须一次完成，不能被打断。

**Q：系统控制的数据结构有哪些？**

> ① 进程管理：
>
> ​		内核会为每个进程创建进程控制块（PCB），里面记录：进程状态（运行、就绪、阻塞）、程序计数器、寄存器内容以及分配的资源。
>
> ② 存储器管理：
>
> ​		内核通过页表、段表、空闲区表等结构来管理内存分配。
>
> ③ 设备管理：
>
> ​		内核维护设备控制表，记录：哪个进程正在使用哪个设备以及设备当前状态。
>

### 1.3.2 中断和异常

1. 中断的作用
   - 让操作系统内核强行夺回 CPU 的控制权。
   - 使 CPU 从用户态变为内核态的唯一方式。
2. 中断的类型
   - 内中断：与当前执行的指令有关，中断信号的来自 CPU 内部。
     - 陷阱、陷入：由应用程序主动触发，是用户故意请求操作系统服务的一种中断。属于软件中断 / 程序性异常。
     - 故障：由错误条件引发，可能被内核程序修复。修复后会把 CPU 的使用权还给应用程序。如：缺页故障。属于软件中断/程序性异常。
     - 终止：由致命错误引起，内核程序无法修复该错误，一般不会将 CPU 使用权还给引发终止的应用程序，而是直接终止该应用程序。如：除 0，非法使用特权指令。属于硬件中断。
   - 外中断：由 CPU 外部的硬件设备 产生的中断，打断当前正在执行的程序。
     - 可屏蔽中断 INTR：时钟中断、I/O 请求中断。
     - 不可屏蔽中断 NMI：断电中断。
3. 中断的基本原理

   - 检测中断信号：内中断还是外中断
   - 找到相应的中断处理程序：通过中断向量表实现。如果能解决，则返回到原指令继续执行，如果不能则终止用户程序。

**Q：什么是内中断的陷阱、陷入？**

> ​		是用户主动触发、用于请求服务。比如，当用户请求读取磁盘文件时，用户态程序通过“陷入”指令主动跳到内核态，由内核完成文件读操作。

**Q：什么是内中断的故障？**

> ​		故障可以被处理，处理后程序继续运行。比如，程序访问的页面不在内存（在磁盘上），引发缺页故障。此时，操作系统会暂停程序，加载缺失页面到内存，页面加载完毕后，程序从故障指令继续执行。

**Q：什么是缺页故障？**

> ​		假设你正在运行一个大型 Word 文档处理程序。该程序使用了 500MB 内存，但当前物理内存只加载了前 100MB，其余部分被放到了磁盘的虚拟内存中。用户滚动页面，程序需要访问第 200MB 处的数据（该数据当前在磁盘中，不在内存）。CPU 检测不到该页存在，触发缺页故障。
>

**Q：什么是内中断的终止？**

> ​		终止无法恢复，程序必须结束。比如，程序出现除以 0 错误，内核立即终止该程序。

**Q：什么是可屏蔽中断？**

> ​		可以通过软件或硬件设置屏蔽开关，暂时禁止或允许响应。一般用于 日常硬件服务请求，对系统不是紧急的。比如，时钟中断。

**Q：什么是不可屏蔽中断？**

> ​		一种无法被屏蔽的紧急中断。通常用于处理极其严重、必须立即响应的硬件问题。比如，工厂生产系统发生电源故障，系统触发不可屏蔽中断，自动保存当前生产状态。
>

### 1.3.3 系统调用

​		系统调用是操作系统对应用程序或程序员提供的接口，系统调用的处理需要由操作系统内核程序负责完成，要运行在核心态。系统调用的过程如下：

1. 传参：应用程序必须告诉操作系统它需要什么。
2. 陷入指令 / trap / 访管：应用程序无法直接访问硬件，必须通过陷入指令（trap） 请求操作系统帮忙。
3. 由操作系统内核程序处理系统调用请求：此时 CPU 已处于核心态，操作系统开始执行实际工作。
4. 返回应用程序：系统调用完成后，操作系统会通过一个专门的返回指令（比如 iret）恢复应用程序执行状态。CPU 从内核态切换回用户态。

​		常见的系统调用的例子有：

1. 进程管理：启动一个新的应用程序。
2. 文件操作：打开 Word 文档进行编辑。
3. 设备管理：调整屏幕显示亮度。

## 1.4 操作系统的体系结构

### 1.4.1 分层法与模块化

​		分层法（想象成圆环）将操作系统分为若干层，最底层（0 层）为硬件，最高层（N 层）为用户接口。每层只能调用紧邻它的低层的功能和服务单向依赖。

​		分层法的优点：

1. 方便调试和验证，自底向上逐调试验证。
2. 易扩充和易维护，各层之间调用接口清晰固定。

​		分层法的缺点：

1. 仅可调用相邻低层，难以合理定义各层的边界。
2. 效率低，不可跨层调用，系统调用执行时间长。

​		模块化（想象成树）指的是将操作系统按功能划分为若干具有一定独立性的模块，每个模块具有某方面的管理功能，并规定好各模块间的接口，使各模块之间能够通过接口进行通信。还可以进一步将各模块细分为若干具有一定功能的子模块，同样也规定好各子模块之间的接口。这种设计方法被称为模块 - 接口法。

​		模块化的优点：

1. 模块间逻辑清晰易于维护，确定模块间接口后即可多模块同时开发。
2. 支持动态加载新的内核模块。(如：安装设备驱动程序、安装新的文件系统到内核)，增强 OS 适应性。
3. 任何模块都可以直接调用其他模块，无需采用消息传递进行通信，效率高。

​		模块化的缺点：

1. 模块间的接口定义未必合理、实用。
2. 模块间相互依赖，难以调试和验证。

### 1.4.2 内核、微内核与外核

​		内核包括主模块和可加载模块。主模块的核心功能有：进程调度、内存管理等。可加载模块可以动态加载新模块到内核，无需重新重置内核。内核的优点在于高性能，内部各种功能可以直接相互调用，但缺点是大内核中某个功能模块出错，有可能导致整个系统崩溃。

​	微内核只把时钟管理、中断、原语、进程通信等最核心的功能放入内核。进程管理、文件管理、设备管理等功能以用户进程的形式运行在用户态。优点是内核功能少，结构清晰，方便维护，且内核中某个功能模块出错，不会导致整个系统崩溃。缺点是需要频繁在核心态和用户态之间进行切换，性能低，用户态下的各功能模块不可以直接相互调用，只能通过内核的"消息传递"来间接通信。

​		外核在底层的内核态中运行，为虚拟机分配资源，并检查使用这些资源的企图，以确保没有机器会使用他人的资源。在这种模式下，内核负责进程调度、进程通信等功能，外核负责为用户进程分配未经抽象的硬件资源，且由外核负责保证资源使用安全。每个用户层的虚拟机可以运行自己的操作系统，但限制只能使用已经申请并且获得分配的那部分资源。优点是外核可直接给用户进程分配"不虚拟、不抽象"的硬件资源，使用户进程可以更灵活的使用硬件资源，减少了虚拟硬件资源的"映射层"，提升效率。缺点是降低了系统的一致性，使系统变得复杂。

**Q：举例说明内核。**

> 例子场景：你使用电脑运行多个程序，并插入一个新的设备（比如 U 盘）。
>
> ​		① 内核主模块：
>
> ​		负责进程调度：比如你同时在运行 Word 和浏览器，内核负责分配 CPU 给这两个程序轮流使用。
>
> ​		负责内存管理：确保每个程序只能使用自己申请的内存，防止互相干扰。
>
> ​		② 可加载模块：
>
> ​		你插入 U 盘时，操作系统会动态加载 U 盘驱动程序模块，系统会立即支持这个设备，不需要重新启动。这个 U 盘驱动就是一个可加载模块，可以按需加载，也可以卸载。

**Q：举例说明外核。**

> 例子场景：使用 VMware、VirtualBox 运行多个虚拟机。
>
> ​		外核（虚拟机监视器）运行在最底层内核态，负责给每个虚拟机分配 CPU、内存、硬盘空间，并限制每个虚拟机只能使用自己申请并被分配的资源，不能访问其他虚拟机的内存或 CPU 时间。
>
> ​		每个虚拟机（用户层）可以安装自己的操作系统，但虚拟机内的系统只能使用被允许的虚拟硬件资源，彼此隔离。
>
> ​		外核就像一栋公寓的物业公司，控制每个住户（虚拟机）只能使用自己的房间和电表，住户可以装修房间（安装不同的操作系统），但不能使用别人的资源。

**Q：内核、外核与操作系统的关系？**

> 操作系统 = 内核 + 外围工具 + 用户接口 + 系统服务
>
> 外核并不是所有操作系统都有的，外核是虚拟化环境的核心组件，如出现在 VMware。